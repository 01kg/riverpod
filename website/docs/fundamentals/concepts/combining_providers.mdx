---
title: Combining providers
---

Make sure to [read about Providers](./provider) first.  
In this guide, we will see everything there is to know about combining providers.


## Combining providers

We've previously seen how to create a simple provider. But the reality is,
in many situation a provider will want to read the state of another provider.

To do that, we can use the `ref` object passed to the callback of our provider,
and use its `read` method.

As an example, consider the following provider:

```dart
final cityProvider = Provider((ref) => 'London');
```

We can now create another provider that will consume our `cityProvider`:

```dart
final weatherProvider = FutureProvider((ref) async {
  // We use `ref.read` to read another provider, and we pass it the provider
  // that we want to consume. Here: cityProvider
  final city = ref.read(cityProvider);

  // We can then use the result to do something based on the value of `cityProvider`.
  return fetchWeather(city: city);
});
```

That's it. We've created a provider that depends on another provider.

### Creating an object that depends on a lot of providers.

Sometimes, we may want to create an object that depends on a lot of providers
like so:

```dart
final cityProvider = Provider((ref) => 'London');
final countryProvider = Provider((ref) => 'England');

final weatherProvider = Provider((ref) {
  final city = ref.read(cityProvider);
  final country = ref.read(countryProvider);

  return Location(city: city, country: country);
});

class Location {
  Location({this.city, this.country});

  final String city;
  final String country;

  String get label => '$city ($country)';
}
```

This can quickly become tedious.

In that situation, it may be reasonable to pass the `ref` variable to our
object directly:

```dart
final cityProvider = Provider((ref) => 'London');
final countryProvider = Provider((ref) => 'England');

final weatherProvider = Provider((ref) {
  // Pass the `ref` object to our `Location` class.
  // `Location` will then be able to call `ref.read` to read the providers.
  return Location(ref);
});

class Location {
  Location(this._ref);

  final ProviderReference _ref;

  String get label {
    final city = _ref.read(cityProvider);
    final country = _ref.read(countryProvider);
    return '$city ($country)';
  }
}
```

This avoids having to implement a constructor, which makes changes on the object
easier.

This is fine as, as opposed to `BuildContext` from Flutter, that `ref` object
is completely independent from Flutter/the UI.  
As such the object can still be shared and tested.

## Disposing the resources the state is destroyed

During the lifetime of an application, the state associated with a provider may
get destroyed.  
In this situation, we may want to perform a clean-up before the state destruction.

This is done by using the `ref` object that is passed to the callback of all providers.

That `ref` object expose an `onDispose` method, which can be used to listen to
the state destruction even to perform some task.

The following example uses `ref.onDispose` to close a `StreamController`:

```dart
final example = StreamProvider((ref) {
  final streamController = StreamController<int>();

  ref.onDispose(() {
    // Closes the StreamController when the state of this provider is destroyed.
    streamController.close();
  });

  return streamController.stream;
});
```

:::note
Depending on the provider used, it may already take care of the clean-up process.  
For example, [StateNotifierProvider] will call the `dispose` method of a `StateNotifier`.
:::

[statenotifierprovider]: https://pub.dev/documentation/riverpod/latest/riverpod/StateNotifierProvider-class.html
